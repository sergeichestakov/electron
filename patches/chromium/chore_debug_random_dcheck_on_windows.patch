From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Kleinschmidt <jkleinsc@electronjs.org>
Date: Tue, 13 Jun 2023 16:16:14 -0400
Subject: chore: debug random DCHECK on Windows

Find out why DCHECK_NE(g_high_res_timer_count, 0u) is firing.

diff --git a/base/task/sequence_manager/thread_controller_with_message_pump_impl.cc b/base/task/sequence_manager/thread_controller_with_message_pump_impl.cc
index 7e027675a96044bd6ef79ea9f41f5d32dfdca5e4..be4decb7a8b769877b0fca03a1c924c70bea04bc 100644
--- a/base/task/sequence_manager/thread_controller_with_message_pump_impl.cc
+++ b/base/task/sequence_manager/thread_controller_with_message_pump_impl.cc
@@ -101,6 +101,7 @@ void ThreadControllerWithMessagePumpImpl::InitializeFeatures() {
   g_use_less_high_res_timers.store(
       FeatureList::IsEnabled(kUseLessHighResTimers), std::memory_order_relaxed);
   if (FeatureList::IsEnabled(kAlwaysUseHighResTimers)) {
+    LOG(INFO) << "In ThreadControllerWithMessagePumpImpl::InitializeFeatures, calling Time::ActivateHighResolutionTimer(true)";
     Time::ActivateHighResolutionTimer(true);
   }
 #endif
@@ -138,6 +139,7 @@ ThreadControllerWithMessagePumpImpl::~ThreadControllerWithMessagePumpImpl() {
 #if BUILDFLAG(IS_WIN)
   if (main_thread_only().in_high_res_mode) {
     main_thread_only().in_high_res_mode = false;
+    LOG(INFO) << "CALLING  Time::ActivateHighResolutionTimer(false); FROM ThreadControllerWithMessagePumpImpl::~ThreadControllerWithMessagePumpImpl ";
     Time::ActivateHighResolutionTimer(false);
   }
 #endif
@@ -341,6 +343,7 @@ ThreadControllerWithMessagePumpImpl::DoWork() {
   if (g_use_less_high_res_timers.load(std::memory_order_relaxed) &&
       main_thread_only().in_high_res_mode) {
     main_thread_only().in_high_res_mode = false;
+    LOG(INFO) << "CALLING  Time::ActivateHighResolutionTimer(false); FROM ThreadControllerWithMessagePumpImpl::DoWork ";
     Time::ActivateHighResolutionTimer(false);
   }
 #endif
@@ -579,6 +582,11 @@ bool ThreadControllerWithMessagePumpImpl::DoIdleWork() {
       // do this the default resolution is 15ms which might not be acceptable
       // for some tasks.
       main_thread_only().in_high_res_mode = need_high_res_mode;
+      if (!need_high_res_mode) {
+        LOG(INFO) << "CALLING  Time::ActivateHighResolutionTimer(false); FROM ThreadControllerWithMessagePumpImpl::DoIdleWork ";
+      } else {
+        LOG(INFO) << "CALLING  Time::ActivateHighResolutionTimer(true); FROM ThreadControllerWithMessagePumpImpl::DoIdleWork ";
+      }
       Time::ActivateHighResolutionTimer(need_high_res_mode);
     }
   }
diff --git a/base/time/time_win.cc b/base/time/time_win.cc
index c6540592a5c1865c125810ca09f53b0540c00aa1..0f579ba4c1679b80d4bb17806491cd7923cc378f 100644
--- a/base/time/time_win.cc
+++ b/base/time/time_win.cc
@@ -32,6 +32,7 @@
 // power.
 
 #include "base/time/time.h"
+#include "base/logging.h"
 
 #include <windows.foundation.h>
 #include <windows.h>
@@ -274,7 +275,12 @@ bool Time::ActivateHighResolutionTimer(bool activating) {
   if (activating) {
     DCHECK_NE(g_high_res_timer_count, max);
     ++g_high_res_timer_count;
+    LOG(INFO) << "Time::ActivateHighResolutionTimer(true); count is now:" << g_high_res_timer_count;
   } else {
+    LOG(INFO) << "Time::ActivateHighResolutionTimer(false); count is now:" << g_high_res_timer_count;
+    if (g_high_res_timer_count == 0u) {
+       LOG(INFO) << "Time::ActivateHighResolutionTimer(false) DANGER!!!!";
+    }
     DCHECK_NE(g_high_res_timer_count, 0u);
     --g_high_res_timer_count;
   }
diff --git a/content/browser/media/capture/desktop_capture_device.cc b/content/browser/media/capture/desktop_capture_device.cc
index ef10371aa95ce930956975171077cccb6567e614..26ff64d26e2f1ec3b4986a41f381dd44c4793415 100644
--- a/content/browser/media/capture/desktop_capture_device.cc
+++ b/content/browser/media/capture/desktop_capture_device.cc
@@ -17,6 +17,7 @@
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/location.h"
+#include "base/logging.h"
 #include "base/memory/raw_ptr.h"
 #include "base/message_loop/message_pump_type.h"
 #include "base/metrics/histogram_macros.h"
@@ -149,11 +150,13 @@ class ScopedHighResolutionTimer {
 #else
   ScopedHighResolutionTimer() {
     if (!base::Time::IsHighResolutionTimerInUse()) {
+      LOG(INFO) << "In ScopedHighResolutionTimer, calling base::Time::ActivateHighResolutionTimer(true)";
       enabled_ = base::Time::ActivateHighResolutionTimer(true);
     }
   }
   ~ScopedHighResolutionTimer() {
     if (enabled_) {
+      LOG(INFO) << "In ~ScopedHighResolutionTimer, calling base::Time::ActivateHighResolutionTimer(false)";
       base::Time::ActivateHighResolutionTimer(false);
     }
   }
diff --git a/ui/gl/vsync_thread_win.cc b/ui/gl/vsync_thread_win.cc
index d9836e3907825a387c21fc23051ec7ed99d5ee19..6205a619ff9c2958e360d043696e04a0fe324ec1 100644
--- a/ui/gl/vsync_thread_win.cc
+++ b/ui/gl/vsync_thread_win.cc
@@ -145,8 +145,10 @@ void VSyncThreadWin::WaitForVSync() {
   if (!wait_for_vblank_succeeded ||
       wait_for_vblank_elapsed_time < kVBlankIntervalThreshold) {
     TRACE_EVENT("gpu", "WaitForVSync Sleep");
+     LOG(INFO) << "In VSyncThreadWin::WaitForVSync about to call base::Time::ActivateHighResolutionTimer(true)";
     base::Time::ActivateHighResolutionTimer(true);
     Sleep(static_cast<DWORD>(vsync_interval.InMillisecondsRoundedUp()));
+    LOG(INFO) << "In VSyncThreadWin::WaitForVSync about to call base::Time::ActivateHighResolutionTimer(false)";
     base::Time::ActivateHighResolutionTimer(false);
   }
 
